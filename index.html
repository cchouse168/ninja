<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
    <title>像素忍者：火之神神樂</title>
    
    <!-- ✅ PWA Manifest 連結 -->
    <link rel="manifest" href="/ninja/manifest.json">
    

    
    <!-- ✅ Icons：照你現有 jpg 檔案 -->
    <link rel="icon" type="image/png" href="/ninja/icon/ninja-1.png">
    <link rel="apple-touch-icon" href="/ninja/icon/ninja-2.png">


    <!-- PWA 元資料 -->
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- 引入 Tone.js 用於生成音效 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: 100dvh;
            width: 100vw;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 16/9;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        /* UI 介面層 */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 10px;
            z-index: 10;
        }

        .status-bar {
            position: absolute;
            top: 10px;
            width: 40%;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #p1-status { left: 10px; align-items: flex-start; }
        #p2-status { right: 10px; align-items: flex-end; }

        .bar-frame {
            height: 15px;
            width: 100%;
            background-color: #111;
            border: 2px solid #444;
            position: relative;
            transform: skewX(-15deg);
            overflow: hidden;
        }

        .health { height: 100%; width: 100%; transition: width 0.1s ease-out; }
        .energy { height: 100%; width: 0%; transition: width 0.1s linear; background-color: #ffd700; box-shadow: 0 0 10px #ffd700; }
        
        .bar-text {
            position: absolute;
            top: -18px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            transform: skewX(0deg);
            text-shadow: 1px 1px 0 #000;
        }

        #timer-group {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 2;
        }
        
        #level-display {
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffd700;
            padding: 2px 10px;
            font-size: 18px;
            font-weight: bold;
            border: 1px solid #ffd700;
            margin-bottom: 5px;
            font-family: 'Impact', sans-serif;
            text-shadow: 0 0 5px #ffd700;
        }

        #timer {
            background-color: rgba(0,0,0,0.8);
            color: #fff;
            width: 50px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            border-bottom: 3px solid #fff;
            font-family: 'Impact', sans-serif;
        }

        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 50;
            pointer-events: auto;
        }

        #start-screen { display: flex; }
        #result-screen { display: none; }

        .overlay-title {
            font-size: 40px;
            color: #ffd700;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            text-align: center;
        }

        .overlay-hint {
            font-size: 16px;
            color: #fff;
            animation: blink 1s infinite;
            padding: 10px 20px;
            border: 2px solid #fff;
            border-radius: 20px;
            background: rgba(255,255,255,0.1);
            cursor: pointer;
            margin-top: 10px;
        }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* === PWA 安裝按鈕 (預設隱藏) === */
        #install-btn {
            display: none; 
            background: #ffd700;
            color: #000;
            font-weight: bold;
            border: 2px solid #fff;
            box-shadow: 0 0 15px #ffd700;
            animation: none;
        }

        /* === 手機虛擬按鍵 === */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            pointer-events: none;
            z-index: 20;
        }

        #d-pad-area {
            position: absolute;
            bottom: 15px;
            left: 20px;
            width: 40%;
            height: 100%;
            pointer-events: auto;
            display: flex;
            align-items: flex-end;
            justify-content: flex-start; 
        }

        .d-pad-visual {
            display: flex;
            flex-direction: row;
            gap: 25px;
            background: rgba(0,0,0,0.25);
            padding: 10px 15px;
            border-radius: 35px;
            backdrop-filter: blur(4px);
        }

        #action-area {
            position: absolute;
            bottom: 15px;
            right: 20px;
            width: 55%;
            height: 100%;
            pointer-events: none;
            display: flex;
            align-items: flex-end;
            justify-content: flex-end;
        }

        #action-buttons {
            display: flex;
            flex-direction: row;
            gap: 15px;
            pointer-events: auto;
        }

        /* 按鍵樣式統一：全部 80px */
        .btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: rgba(255,255,255,0.9);
            font-size: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            pointer-events: auto;
            transition: transform 0.1s, background 0.1s;
            user-select: none;
        }

        .btn.active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.9);
            color: #fff;
        }

        .btn.cooldown {
            opacity: 0.4;
            background: rgba(0, 0, 0, 0.5);
            border-color: #555;
            pointer-events: none; 
        }

        #btn-jump, #btn-attack, #btn-ult { position: static; }

        #btn-attack {
            width: 80px;
            height: 80px;
            background: rgba(255, 50, 50, 0.25);
            border-color: rgba(255, 50, 50, 0.6);
            font-size: 30px;
        }
        #btn-attack.active { background: rgba(255, 50, 50, 0.7); }

        #btn-ult {
            width: 80px;
            height: 80px;
            background: rgba(50, 50, 50, 0.85);
            border-color: #888;
            font-size: 14px;
            flex-direction: column;
            line-height: 1.2;
        }

        #btn-ult span { font-size: 12px; }

        #btn-ult.ready {
            background: radial-gradient(circle, #ffd700, #ff8c00);
            border-color: #fff;
            box-shadow: 0 0 20px #ff8c00;
            animation: pulse 0.5s infinite alternate;
            color: #000;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to   { transform: scale(1.08); }
        }

        /* 平板/桌面適配 */
        @media (max-width: 900px) {
            .btn { width: 68px; height: 68px; font-size: 24px; }
            #btn-attack, #btn-ult { width: 68px; height: 68px; }
        }

        #orientation-hint {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; color: white;
            justify-content: center; align-items: center; text-align: center;
        }
        @media screen and (orientation: portrait) { #orientation-hint { display: flex; } }
    </style>
</head>
<body>

<div id="orientation-hint">請旋轉手機 (橫向)</div>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="p1-status" class="status-bar">
            <div class="bar-text">PLAYER 1</div>
            <div class="bar-frame"><div id="player-health" class="health" style="background: linear-gradient(90deg, #ff3333, #ff6666);"></div></div>
            <div class="bar-frame" style="height: 8px; border: none; background: #333;"><div id="player-energy" class="energy"></div></div>
        </div>

        <div id="timer-group">
            <div id="level-display">LEVEL 1</div>
            <div id="timer">60</div>
        </div>

        <div id="p2-status" class="status-bar">
            <div class="bar-text" style="right:0;">COMPUTER</div>
            <div class="bar-frame"><div id="enemy-health" class="health" style="background: linear-gradient(90deg, #3366ff, #6699ff); float: right;"></div></div>
            <div class="bar-frame" style="height: 8px; border: none; background: #333;"><div id="enemy-energy" class="energy" style="float: right;"></div></div>
        </div>
    </div>

    <div id="start-screen" class="overlay-screen">
        <div class="overlay-title">PIXEL NINJA</div>
        <div class="overlay-hint" id="start-btn">點擊開始 (全螢幕)</div>
        <!-- PWA 安裝按鈕：預設隱藏，等 JS 觸發顯示 -->
        <div class="overlay-hint" id="install-btn">⬇️ 安裝 App (PWA)</div>
    </div>

    <div id="result-screen" class="overlay-screen">
        <div class="overlay-title" id="result-text">KO</div>
        <div class="overlay-hint" id="restart-btn">點擊重來</div>
    </div>

    <div id="mobile-controls">
        <div id="d-pad-area">
            <div class="d-pad-visual">
                <div class="btn" id="btn-left">◀</div>
                <div class="btn" id="btn-right">▶</div>
            </div>
        </div>

        <div id="action-area">
            <div id="action-buttons">
                <!-- 順序：奧義 (左) -> 斬 (中) -> 跳 (右) -->
                <div class="btn" id="btn-ult">奧義<br><span>0%</span></div>
                <div class="btn" id="btn-attack">斬</div>
                <div class="btn" id="btn-jump">跳</div>
            </div>
        </div>
    </div>
</div>

<script>
    // === PWA 安裝邏輯 ===
    let deferredPrompt;
    const installBtn = document.getElementById('install-btn');

    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        installBtn.style.display = 'block';
        console.log('PWA install prompt intercepted');
    });

    installBtn.addEventListener('click', async () => {
        if (deferredPrompt) {
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            console.log(`User response to install prompt: ${outcome}`);
            deferredPrompt = null;
            installBtn.style.display = 'none';
        }
    });

    // 註冊 Service Worker
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/ninja/sw.js')
                .then(reg => console.log('Service Worker Registered'))
                .catch(err => console.log('Service Worker Error:', err));
        });
    }

    const canvas = document.querySelector('canvas');
    const c = canvas.getContext('2d');

    canvas.width = 1024;
    canvas.height = 576;

    const gravity = 0.4;
    const moveSpeed = 3;
    const jumpForce = -12;

    let screenShake = 0;
    let gameRunning = false;
    let currentLevel = 1;
    let timerInterval = null;
    let animationId = null;

    const ENEMY_COLORS = {
        1: '#3366ff',
        2: '#33cc33',
        3: '#cc33cc',
        4: '#ff8c00',
        5: '#000000'
    };

    const AI_DIFFICULTY = {
        1: { speed: 2, attackChance: 0.04, jumpChance: 0.01 },
        2: { speed: 3, attackChance: 0.07, jumpChance: 0.02 },
        3: { speed: 4, attackChance: 0.10, jumpChance: 0.03 },
        4: { speed: 5, attackChance: 0.13, jumpChance: 0.04 },
        5: { speed: 5, attackChance: 0.18, jumpChance: 0.05 }
    };

    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');
    const gameContainer = document.documentElement;
    const resultScreen = document.getElementById('result-screen');
    const resultText = document.getElementById('result-text');
    const restartBtn = document.getElementById('restart-btn');
    const btnAttack = document.getElementById('btn-attack');

    const sfx = {
        init: false,
        polySynth: null,
        noiseSynth: null,
        metalSynth: null,

        async initAudio() {
            if (this.init) return;
            await Tone.start();
            
            this.polySynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sawtooth" }, 
                envelope: { attack: 0.02, decay: 0.3, sustain: 0.3, release: 1 },
                volume: -12
            }).toDestination();
            
            const reverb = new Tone.Reverb({ decay: 3, wet: 0.3 }).toDestination();
            this.polySynth.connect(reverb);

            this.noiseSynth = new Tone.NoiseSynth({
                noise: { type: 'pink' },
                envelope: { attack: 0.001, decay: 0.2, sustain: 0 },
                volume: -15
            }).toDestination();

            this.metalSynth = new Tone.MetalSynth({
                frequency: 200,
                envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
                harmonicity: 5.1,
                modulationIndex: 32,
                resonance: 4000,
                octaves: 1.5,
                volume: -8
            }).toDestination();

            this.init = true;
        },

        play(type) {
            if (!this.init) return;
            const now = Tone.now();
            try {
                switch(type) {
                    case 'jump':
                        this.polySynth.triggerAttackRelease(["C4", "E4"], "16n", now);
                        break;
                    case 'slash':
                        this.noiseSynth.triggerAttackRelease("16n", now);
                        this.polySynth.triggerAttackRelease(["G2"], "32n", now);
                        break;
                    case 'ultimate':
                        this.polySynth.triggerAttackRelease(["D2", "A2", "D3", "G3"], "1n", now); 
                        this.noiseSynth.triggerAttackRelease("2n", now); 
                        this.metalSynth.triggerAttackRelease("16n", now); 
                        this.polySynth.triggerAttackRelease(["D2", "A2", "D3", "F#3"], "2n", now + 0.5); 
                        break;
                    case 'hit':
                        this.metalSynth.triggerAttackRelease("8n", now);
                        this.polySynth.triggerAttackRelease(["C2", "F#2"], "32n", now);
                        break;
                }
            } catch(e) { console.log(e); }
        }
    };

    startBtn.addEventListener('click', async () => {
        startScreen.style.display = 'none';
        await sfx.initAudio();
        setupLevel(1);
        animate();
        try {
            if (gameContainer.requestFullscreen) await gameContainer.requestFullscreen();
            else if (gameContainer.webkitRequestFullscreen) await gameContainer.webkitRequestFullscreen();
        } catch (err) { console.warn('Fullscreen blocked:', err); }
    });

    class Sprite {
        constructor({ position, velocity, color, offset = { x: 0, y: 0 }, isEnemy = false }) {
            this.position = position;
            this.velocity = velocity;
            this.width = 50;
            this.height = 100;
            this.attackBox = {
                position: { x: this.position.x, y: this.position.y },
                offset: offset,
                width: 120,
                height: 50
            };
            this.color = color;
            this.isAttacking = false;
            this.isAttackCooldown = false;
            this.health = 100;
            this.isEnemy = isEnemy;
            this.facing = isEnemy ? 'left' : 'right';
            this.isHit = false;
            this.energy = 0;
            this.isUltimate = false;
            this.isDead = false;
            this.ultimateFrame = 0;
            this.particles = []; 
        }

        draw() {
            if (this.isDead && !this.isUltimate) return;

            const x = this.position.x;
            const y = this.position.y;
            const centerX = x + this.width / 2;
            const centerY = y + this.height / 2;

            if (this.isUltimate) {
                c.save();
                c.fillStyle = 'rgba(0, 0, 0, 0.7)';
                c.fillRect(-1000, -1000, 4000, 4000);

                if (this.ultimateFrame < 60) { 
                    for(let i=0; i<3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        this.particles.push({
                            x: centerX + Math.cos(angle) * 10,
                            y: centerY + Math.sin(angle) * 10,
                            vx: Math.cos(angle) * (Math.random() * 10 + 5),
                            vy: Math.sin(angle) * (Math.random() * 10 + 5),
                            life: 1.0,
                            size: Math.random() * 4 + 2
                        });
                    }
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.03;
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    } else {
                        c.beginPath();
                        c.arc(p.x, p.y, p.size, 0, Math.PI*2);
                        c.fillStyle = `rgba(255, 200, 50, ${p.life})`;
                        c.fill();
                    }
                }

                c.translate(centerX, centerY);
                if (this.facing === 'left') c.scale(-1, 1);

                const rotation = (this.ultimateFrame * 0.15) - 0.5; 
                c.rotate(rotation);
                c.globalCompositeOperation = 'lighter';

                const radius = 250;
                this.drawFlameArc(radius + 20, '#ff0055', 40, 15, 0.6);
                this.drawFlameArc(radius, '#ff6600', 30, 10, 0.8);
                this.drawFlameArc(radius - 20, '#ffcc00', 20, 5, 0.9);
                this.drawFlameArc(radius - 35, '#ffffff', 10, 2, 1.0);

                c.restore();

                c.save();
                c.globalAlpha = Math.min(1, this.ultimateFrame / 10);
                if (this.ultimateFrame > 50) c.globalAlpha = Math.max(0, (70 - this.ultimateFrame) / 20);
                
                c.font = 'italic 900 60px sans-serif';
                const textGradient = c.createLinearGradient(centerX - 80, y - 120, centerX + 80, y - 80);
                textGradient.addColorStop(0, '#ffffff');
                textGradient.addColorStop(0.4, '#ffe08a');
                textGradient.addColorStop(1, '#ffb347');

                c.fillStyle = textGradient;
                c.textAlign = 'center';
                c.shadowColor = 'rgba(255, 50, 50, 0.8)';
                c.shadowBlur = 20;
                c.fillText('火之神神樂', centerX, y - 80);
                c.strokeStyle = '#ff4500';
                c.lineWidth = 2;
                c.strokeText('火之神神樂', centerX, y - 80);
                c.restore();
            }

            let legOffset = 0, armOffset = 0;
            if (Math.abs(this.velocity.x) > 0.5 && this.velocity.y === 0) {
                legOffset = Math.sin(Date.now() / 80) * 15;
                armOffset = Math.cos(Date.now() / 80) * 15;
            } else if (this.velocity.y !== 0) {
                legOffset = -10; armOffset = -20;
            }

            const limbColor = this.color;
            const skinColor = '#ffccaa';

            c.fillStyle = this.color;
            c.fillRect(x + 10, y + 35, 30, 45);

            c.fillStyle = skinColor;
            c.fillRect(x + 10, y + 5, 30, 30);
            c.fillStyle = this.color;
            c.fillRect(x + 10, y, 30, 10);
            if (this.facing === 'right') c.fillRect(x - 10, y + 2, 20, 6);
            else c.fillRect(x + 40, y + 2, 20, 6);

            c.fillStyle = 'white';
            let eyeX = this.facing === 'right' ? x + 28 : x + 12;
            c.fillRect(eyeX, y + 12, 8, 8);
            c.fillStyle = 'black';
            c.fillRect(eyeX + (this.facing==='right'?3:1), y + 14, 3, 3);

            c.fillStyle = '#111';
            c.fillRect(centerX - 5 + (this.facing==='right'?-legOffset:legOffset), y + 80, 10, 20);
            c.fillRect(centerX - 5 + (this.facing==='right'?legOffset:-legOffset), y + 80, 10, 20);

            c.fillStyle = limbColor;
            c.fillRect(centerX - 20 + armOffset, y + 40, 10, 25);

            let weaponX = centerX + 10 - armOffset;
            let weaponY = y + 40;
            if (this.isAttacking) {
                weaponX = this.facing === 'right' ? x + 40 : x - 10;
                weaponY = y + 30;
            }
            c.fillRect(weaponX, weaponY, 10, 25);

            c.save();
            c.translate(weaponX + 5, weaponY + 20);
            if (this.isAttacking) c.rotate(this.facing === 'right' ? 1.8 : -1.8);
            else c.rotate(this.facing === 'right' ? -0.5 : 0.5);
            c.fillStyle = '#444'; c.fillRect(-3, 0, 6, 15);
            c.fillStyle = '#ddd'; c.fillRect(-2, -40, 4, 40);
            c.restore();

            if (this.isAttacking && !this.isUltimate) {
                c.save();
                c.translate(centerX, centerY);
                if (this.facing === 'left') c.scale(-1, 1); 

                c.beginPath();
                c.moveTo(20, -20);
                c.bezierCurveTo(80, -50, 120, 0, 120, 50);
                c.bezierCurveTo(80, 20, 50, 0, 20, -20);
                
                const slashGrad = c.createLinearGradient(20, -20, 120, 50);
                slashGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                slashGrad.addColorStop(0.5, 'rgba(200, 230, 255, 0.8)');
                slashGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');

                c.fillStyle = slashGrad;
                c.shadowColor = 'rgba(200, 240, 255, 0.8)';
                c.shadowBlur = 15;
                c.fill();
                
                c.beginPath();
                c.moveTo(20, -20);
                c.bezierCurveTo(80, -50, 120, 0, 120, 50);
                c.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                c.lineWidth = 2;
                c.stroke();

                c.restore();
            }

            if (this.isHit) {
                c.fillStyle = 'rgba(255, 255, 255, 0.7)';
                c.fillRect(x, y, this.width, this.height);
            }
        }

        drawFlameArc(radius, color, width, jaggedness, opacity) {
            c.beginPath();
            c.shadowBlur = 20;
            c.shadowColor = color;
            c.fillStyle = color;
            c.globalAlpha = opacity;

            const startAngle = -Math.PI * 0.8;
            const endAngle = Math.PI * 0.8;
            const steps = 60;

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const angle = startAngle + t * (endAngle - startAngle);
                const flicker = (Math.random() - 0.5) * jaggedness;
                const taper = Math.sin(t * Math.PI);
                const r = radius + flicker + (width * taper * 0.5);
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;
                if (i === 0) c.moveTo(px, py);
                else c.lineTo(px, py);
            }

            for (let i = steps; i >= 0; i--) {
                const t = i / steps;
                const angle = startAngle + t * (endAngle - startAngle);
                const taper = Math.sin(t * Math.PI);
                const r = radius - (width * taper * 0.5);
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;
                c.lineTo(px, py);
            }

            c.closePath();
            c.fill();
        }

        update() {
            if (this.isDead) return;
            this.draw();

            if (this.energy < 100) {
                this.energy += 0.08;
                updateEnergyUI();
            }

            if (this.isUltimate) {
                this.ultimateFrame++;
                this.attackBox.width = 600; 
                this.attackBox.height = 500;
                this.attackBox.position.y = this.position.y - 200;
                
                if (this.facing === 'right') {
                    this.attackBox.position.x = this.position.x - 100;
                } else {
                    this.attackBox.position.x = this.position.x - 450;
                }
            } else {
                this.ultimateFrame = 0;
                this.attackBox.width = 120;
                this.attackBox.height = 50;
                if (this.facing === 'right') {
                    this.attackBox.position.x = this.position.x + this.width;
                    this.attackBox.offset.x = 0;
                } else {
                    this.attackBox.position.x = this.position.x - this.attackBox.width;
                    this.attackBox.offset.x = -this.attackBox.width;
                }
                this.attackBox.position.y = this.position.y + 30;
            }

            this.position.x += this.velocity.x;
            this.position.y += this.velocity.y;

            if (this.position.y + this.height + this.velocity.y >= canvas.height - 60) {
                this.velocity.y = 0;
                this.position.y = canvas.height - 60 - this.height;
            } else {
                this.velocity.y += gravity;
            }

            if (this.position.x < 0) this.position.x = 0;
            if (this.position.x + this.width > canvas.width) this.position.x = canvas.width - this.width;

            if (this.velocity.x > 0) this.facing = 'right';
            if (this.velocity.x < 0) this.facing = 'left';
        }

        attack() {
            if (!this.isAttacking && !this.isDead && !this.isAttackCooldown) {
                this.isAttacking = true;
                this.isUltimate = false;
                this.isAttackCooldown = true;
                
                if (!this.isEnemy) sfx.play('slash');

                if (!this.isEnemy) {
                    btnAttack.classList.add('cooldown');
                }
                
                setTimeout(() => { 
                    this.isAttacking = false; 
                }, 150);

                setTimeout(() => {
                    this.isAttackCooldown = false;
                    if (!this.isEnemy) {
                        btnAttack.classList.remove('cooldown');
                    }
                }, 400);
            }
        }

        ultimateAttack() {
            if (this.energy >= 100 && !this.isAttacking && !this.isDead) {
                this.isAttacking = true;
                this.isUltimate = true;
                this.energy = 0;
                this.particles = [];
                updateEnergyUI();
                screenShake = 32;

                if (!this.isEnemy) sfx.play('ultimate');

                setTimeout(() => {
                    this.isAttacking = false;
                    this.isUltimate = false;
                }, 1100);
            }
        }
    }

    const player = new Sprite({
        position: { x: 150, y: 0 },
        velocity: { x: 0, y: 0 },
        color: '#ff3333',
        isEnemy: false
    });

    const enemy = new Sprite({
        position: { x: 800, y: 0 },
        velocity: { x: 0, y: 0 },
        color: ENEMY_COLORS[1],
        isEnemy: true
    });

    const btnUlt = document.getElementById('btn-ult');
    function updateEnergyUI() {
        document.querySelector('#player-energy').style.width = Math.min(100, player.energy) + '%';
        document.querySelector('#enemy-energy').style.width = Math.min(100, enemy.energy) + '%';

        if (player.energy >= 100) {
            btnUlt.classList.add('ready');
            btnUlt.innerHTML = '奧義<br>READY (↓)';
        } else {
            btnUlt.classList.remove('ready');
            btnUlt.innerHTML = `奧義<br><span>${Math.floor(player.energy)}%</span>`;
        }
    }

    const keys = { left: { pressed: false }, right: { pressed: false } };

    function rectangularCollision({ rectangle1, rectangle2 }) {
        return (
            rectangle1.attackBox.position.x < rectangle2.position.x + rectangle2.width &&
            rectangle1.attackBox.position.x + rectangle1.attackBox.width > rectangle2.position.x &&
            rectangle1.attackBox.position.y < rectangle2.position.y + rectangle2.height &&
            rectangle1.attackBox.position.y + rectangle1.attackBox.height > rectangle2.position.y
        );
    }

    let timer = 60;

    function decreaseTimer() {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            if (!gameRunning) {
                clearInterval(timerInterval);
                return;
            }
            if (timer > 0) {
                timer--;
                document.querySelector('#timer').innerText = timer;
            }
            if (timer === 0) {
                clearInterval(timerInterval);
                determineWinner({ player, enemy, timeOut: true });
            }
        }, 1000);
    }

    function determineWinner({ player, enemy, timeOut = false }) {
        gameRunning = false;
        if (timerInterval) clearInterval(timerInterval);
        if (animationId) cancelAnimationFrame(animationId);

        player.velocity.x = 0; player.velocity.y = 0;
        enemy.velocity.x = 0; enemy.velocity.y = 0;
        player.isAttacking = false;
        enemy.isAttacking = false;

        let win = false;
        if (player.health > enemy.health) win = true;
        else if (timeOut && player.health === enemy.health) win = false;
        else if (!timeOut && player.health > 0 && enemy.health <= 0) win = true;

        resultScreen.style.display = 'flex';

        if (win) {
            if (currentLevel < Object.keys(ENEMY_COLORS).length) {
                resultText.innerHTML = `LEVEL ${currentLevel} CLEARED!`;
                resultText.style.color = '#ffd700';
                restartBtn.innerText = `下一關 (LEVEL ${currentLevel + 1})`;
                restartBtn.onclick = () => {
                    resultScreen.style.display = 'none';
                    setupLevel(currentLevel + 1);
                    animate();
                };
            } else {
                resultText.innerHTML = '恭喜！忍者傳說達成！';
                resultText.style.color = '#ff4d4d';
                restartBtn.innerText = '重新開始 (LEVEL 1)';
                restartBtn.onclick = () => { location.reload(); };
            }
        } else {
            resultText.innerHTML = (timeOut && player.health === player.health) ? 'TIME OUT / DRAW' : 'YOU LOSE';
            resultText.style.color = '#ff4d4d';
            restartBtn.innerText = '重新開始 (LEVEL 1)';
            restartBtn.onclick = () => { location.reload(); };
        }
    }

    function setupLevel(level) {
        currentLevel = level;
        gameRunning = true;
        document.getElementById('level-display').innerText = `LEVEL ${currentLevel}`;

        timer = 60;
        document.querySelector('#timer').innerText = timer;
        decreaseTimer();

        player.health = 100;
        player.energy = 0;
        player.position = { x: 150, y: 0 };
        player.velocity = { x: 0, y: 0 };
        player.isDead = false;
        player.isHit = false; // 確保重置
        player.isUltimate = false;
        player.facing = 'right';
        player.particles = [];
        player.isAttackCooldown = false;
        btnAttack.classList.remove('cooldown');

        enemy.health = 100;
        enemy.energy = 0;
        enemy.position = { x: 800, y: 0 };
        enemy.velocity = { x: 0, y: 0 };
        enemy.isDead = false;
        enemy.isHit = false; // === 修正：確保每一關開始時重置受傷狀態 ===
        enemy.isUltimate = false;
        enemy.color = ENEMY_COLORS[currentLevel] || ENEMY_COLORS[1];
        enemy.facing = 'left';
        enemy.particles = [];
        enemy.isAttackCooldown = false;

        document.querySelector('#player-health').style.width = '100%';
        document.querySelector('#enemy-health').style.width = '100%';
        updateEnergyUI();
    }

    function updateEnemyAI() {
        if (!gameRunning || enemy.isDead) return;

        const difficulty = AI_DIFFICULTY[currentLevel] || AI_DIFFICULTY[1];
        const aiSpeed = difficulty.speed;
        const aiAttackChance = difficulty.attackChance;
        const aiJumpChance = difficulty.jumpChance;

        if (player.position.x < enemy.position.x) enemy.facing = 'left';
        else enemy.facing = 'right';

        const distance = Math.abs(player.position.x - enemy.position.x);

        if (enemy.energy >= 100 && distance < 500 && Math.random() < 0.9) {
            enemy.ultimateAttack();
            return;
        }

        if (distance > 100) {
            if (player.position.x < enemy.position.x) enemy.velocity.x = -aiSpeed;
            else enemy.velocity.x = aiSpeed;
        } else {
            enemy.velocity.x = 0;
            if (Math.random() < aiAttackChance) enemy.attack();
            if (Math.random() < aiJumpChance && enemy.velocity.y === 0) enemy.velocity.y = jumpForce;
        }

        if (enemy.position.x <= 0) enemy.velocity.x = 2;
        if (enemy.position.x + enemy.width >= canvas.width) enemy.velocity.x = -2;
    }

    function animate() {
        if (!gameRunning) return;

        animationId = window.requestAnimationFrame(animate);

        c.save();
        if (screenShake > 0) {
            const dx = (Math.random() - 0.5) * screenShake;
            const dy = (Math.random() - 0.5) * screenShake;
            c.translate(dx, dy);
            screenShake *= 0.9;
            if (screenShake < 0.5) screenShake = 0;
        }

        c.fillStyle = '#222';
        c.fillRect(-100, -100, canvas.width + 200, canvas.height + 200);

        c.fillStyle = '#1a1a1a';
        c.fillRect(-100, canvas.height - 60, canvas.width + 200, 100);
        c.fillStyle = '#333';
        for (let i = 0; i < canvas.width; i += 100) c.fillRect(i, canvas.height - 60, 2, 60);

        player.update();
        enemy.update();
        updateEnemyAI();

        c.restore();

        player.velocity.x = 0;
        if (keys.left.pressed && player.position.x > 0) player.velocity.x = -moveSpeed;
        else if (keys.right.pressed && player.position.x < canvas.width - player.width) player.velocity.x = moveSpeed;

        const handleHit = (attacker, defender, statusId) => {
            if (rectangularCollision({ rectangle1: attacker, rectangle2: defender }) &&
                attacker.isAttacking && !defender.isHit) {

                defender.isHit = true;
                const damage = attacker.isUltimate ? 40 : 8;
                defender.health -= damage;

                attacker.isUltimate ? screenShake = 32 : screenShake = 5;
                if (!attacker.isUltimate) {
                    attacker.energy = Math.min(100, attacker.energy + 20);
                    updateEnergyUI();
                }
                
                sfx.play('hit');

                document.querySelector(statusId).style.width = Math.max(0, defender.health) + '%';
                
                if (defender.health <= 0) {
                    determineWinner({ player, enemy });
                    defender.isDead = true;
                    return;
                }

                const pushBack = attacker.isUltimate ? 160 : 30;
                if (attacker.facing === 'right') defender.position.x += pushBack;
                else defender.position.x -= pushBack;

                const iframeTime = attacker.isUltimate ? 1200 : 400;
                setTimeout(() => defender.isHit = false, iframeTime);
            }
        };

        handleHit(player, enemy, '#enemy-health');
        handleHit(enemy, player, '#player-health');
    }

    window.addEventListener('keydown', (event) => {
        if (!gameRunning) return;
        switch (event.key) {
            case 'd': case 'ArrowRight': keys.right.pressed = true; break;
            case 'a': case 'ArrowLeft': keys.left.pressed = true; break;
            case 'w': case 'ArrowUp': 
                if (player.velocity.y === 0) {
                    player.velocity.y = jumpForce;
                    sfx.play('jump');
                }
                break;
            case ' ': player.attack(); break;
            case 's': case 'ArrowDown': player.ultimateAttack(); break;
        }
    });

    window.addEventListener('keyup', (event) => {
        switch (event.key) {
            case 'd': case 'ArrowRight': keys.right.pressed = false; break;
            case 'a': case 'ArrowLeft': keys.left.pressed = false; break;
        }
    });

    const dPadArea = document.getElementById('d-pad-area');
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const btnJump = document.getElementById('btn-jump');
    
    // === 虛擬按鍵邏輯修正 ===
    dPadArea.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleDPadTouch(e.touches[0]);
    }, { passive: false });

    dPadArea.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleDPadTouch(e.touches[0]);
    }, { passive: false });

    dPadArea.addEventListener('touchend', (e) => {
        e.preventDefault();
        keys.left.pressed = false;
        keys.right.pressed = false;
        btnLeft.classList.remove('active');
        btnRight.classList.remove('active');
    });

    function handleDPadTouch(touch) {
        const rect = dPadArea.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const centerX = rect.width / 2; 
        
        keys.left.pressed = false;
        keys.right.pressed = false;
        btnLeft.classList.remove('active');
        btnRight.classList.remove('active');

        if (x < centerX) { 
            keys.left.pressed = true;
            btnLeft.classList.add('active');
        } else { 
            keys.right.pressed = true;
            btnRight.classList.add('active');
        }
    }

    const addTouchBtn = (elem, action) => {
        elem.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!elem.classList.contains('cooldown')) { 
                elem.classList.add('active');
                action();
            }
        }, { passive: false });
        elem.addEventListener('touchend', (e) => {
            e.preventDefault();
            elem.classList.remove('active');
        });
    };

    addTouchBtn(btnJump, () => { 
        if (player.velocity.y === 0) {
            player.velocity.y = jumpForce;
            sfx.play('jump');
        }
    });
    addTouchBtn(btnAttack, () => player.attack());
    addTouchBtn(btnUlt, () => player.ultimateAttack());

</script>
</body>
</html>





